% Implementation details for the path finding problemsas the Pacman plans and replans in the environment; figures are helpful here. 

\section{Implementation Details}\label{sec:implementation}

	All implementation was done in Python2, for ease of integration with other systems. 

\subsection{Pacman}

	A common context for measuring pathfinding and route-planning algorithms is through the classic arcade game, Pacman. By adjusting different aspects of gameplay, such as the presence of ghosts, fore-knowledge of wall locations, density and placement of food pellets, and so on, a wide variety of heterogeneous environmental configurations can be used to explore different avenues of route planning.
	
	

\subsection{Naïve-Replanning A*}

	Naïve-Replanning A* (or NRA*) describes a strategy where the agent first generates a shortest-path estimate to the desired goal using the well-known A* algorithm \cite{hart1968formal}, and then follows that path. As the agent moves through the partially-observable environment, if the route is interrupted by any impassable barriers (such as walls), it updates an internal representation of the environment with that information. It then generates a new shortest path from scratch using A*, using its current location as the start location, the original goal as the new goal, and the updated environmental representation as a modified graph.
	
	This approach is called ``naïve" because it does not re-use any of the previous planning computations for later replanning, which can lead to re-exploration of many states, and unnecessarily duplicated computation. However, it will provide an optimal solution, as A* is guaranteed to find the best route given the known environmental information.
	
	These characteristics (optimal routes, inefficient computation) provided an effective baseline for our comparison, allowing differences between possible routes found through other approaches to be easily detected, although no such differences were expected due to the guarantees provided by the other approaches. Additionally, it established an upper-limit on the number of nodes expanded, since no exploration is reused. In conjunction with the lower-limit established by an omniscient agent using a single, optimal A* search, this permitted a theoretical bounding for the other approaches under consideration.

\subsection{Lifelong-Planning A*}
	Lifelong Planning A* was implemented by by focusing on a core implementation, then by making small changes to configure it with the Pacman domain. This was accomplished using object oriented design principles. In particular, the LPA* object must be instantiated with the maze dimensions, the start location, and goal location. It maintains a list of so-called naive walls, which are the walls the agent knows exist up to that current point in time. There is also a mechanism with which the agent can ``make'' a wall in the naive walls so that its knowledge about the maze can persist. The group essentially implemented a wrapper around this LPA* object: initially supplying information, iteratively extracting path steps from the object, and supplying information about the true walls to the object. Since the LPA* agent can backtrack, i.e. revisit parts of the maze multiple times, care had to be taken to make sure that this backtracking behavior was captured in the final path returned for visualization. Each time new information was supplied to the LPA* object, if this associated update caused any of the edge weights to become locally inconsistent, then the LPA* object would update the specific vertex, and possible generate a new search plan.
	
	One of the challenges that the group faced with this part of the implementation was representing the search process that the Pacman took. Instead of simply returning the final path, if there was a backtracking situation, the backtrack path had to be appended to the existing path without any overlap. Extensive debugging was involved with this functionality.
	

\subsection{D* Lite}
	Similar to the LPA* implementation, the D* Lite algorithm was also implemented in an object oriented manner. The overall search again acted as a wrapper to the D* Lite object, initializing it, and iteratively extracting information from and updating information in the object. However there was a subtle difference in how the D* Lite object operates. With the D* Lite object, we could simply take a step with the object, extract information from the walls, and repeat. The reason that no backtracking had to be taken into account is because the D* Lite algorithm only expands those nodes which will affect the final path, and this avoids the backtrack step.
	
	Another specific challenge that the group faced with both LPA* and D* Lite integration were the initial differences between the core algorithm and Pacman domain. In particular, the core algorithm used a coordinate system that was transposed with respect to the Pacman domain. Additionally, the core implementation returned a list of coordinate points, rather than actions. Both of these discrepancies had to be re-factored in the code. Finally, the Pacman domain maintains a count of nodes expanded, each time a call to \text{get successors} is made. Since our LPA* and D* Lite core did not interact with \text{get successors}, an internal count had to be maintained so that it could be tracked as a metric for evaluation. 

\subsection{Test Coverage}

	To ensure correct execution of the implementations, unit tests were created in conjunction with the PyCoverage tool. These units tests were used to test the correctness of the implementations against a series of inputs and expected outputs for both the underlying algorithmic implementations, as well as the supporting data structures and algorithms used.
	
	Additionally, these tests were useful in performing regression testing, to ensure that changes to the core algorithmic implementations necessary for integration with the Pacman domain did not compromise their underlying logic.
	
	Our test suite provided complete (100\%) coverage for all core implementations and supporting libraries which were implemented in the course of this project. Supporting code, such as that provided through the Pacman project, system libraries, or other external sources was judged as outside the scope of our testing strategy.


