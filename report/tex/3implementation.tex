% Implementation details for the path finding problemsas the Pacman plans and replans in the environment; figures are helpful here. 

\section{Implementation Details}\label{sec:implementation}

	All implementation was done in Python2, for ease of integration with other systems. 

\subsection{Pacman}

	A common context for measuring pathfinding and route-planning algorithms is through the classic arcade game, Pacman. By adjusting different aspects of gameplay, such as the presence of ghosts, fore-knowledge of wall locations, density and placement of food pellets, and so on, a wide variety of heterogeneous environmental configurations can be used to explore different avenues of route planning.
	
	

\subsection{Naïve-Replanning A*}

	Naïve-Replanning A* (or NRA*) describes a strategy where the agent first generates a shortest-path estimate to the desired goal using the well-known A* algorithm \cite{hart1968formal}, and then follows that path. As the agent moves through the partially-observable environment, if the route is interrupted by any impassable barriers (such as walls), it updates an internal representation of the environment with that information. It then generates a new shortest path from scratch using A*, using its current location as the start location, the original goal as the new goal, and the updated environmental representation as a modified graph.
	
	This approach is called ``naïve" because it does not re-use any of the previous planning computations for later replanning, which can lead to re-exploration of many states, and unnecessarily duplicated computation. However, it will provide an optimal solution, as A* is guaranteed to find the best route given the known environmental information.
	
	These characteristics (optimal routes, inefficient computation) provided an effective baseline for our comparison, allowing differences between possible routes found through other approaches to be easily detected, although no such differences were expected due to the guarantees provided by the other approaches. Additionally, it established an upper-limit on the number of nodes expanded, since no exploration is reused. In conjunction with the lower-limit established by an omniscient agent using a single, optimal A* search, this permitted a theoretical bounding for the other approaches under consideration.

\subsection{Lifelong-Planning A*}

	

\subsection{D* Lite}


\subsection{Test Coverage}

	To ensure correct execution of the implementations, unit tests were created in conjunction with the PyCoverage tool. These units tests were used to test the correctness of the implementations against a series of inputs and expected outputs for both the underlying algorithmic implementations, as well as the supporting data structures and algorithms used.
	
	Additionally, these tests were useful in performing regression testing, to ensure that changes to the core algorithmic implementations necessary for integration with the Pacman domain did not compromise their underlying logic.
	
	Our test suite provided complete (100\%) coverage for all core implementations and supporting libraries which were implemented in the course of this project. Supporting code, such as that provided through the Pacman project, system libraries, or other external sources was judged as outside the scope of our testing strategy.


